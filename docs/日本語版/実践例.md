# 実践例: Speckitで機能を開発する

このドキュメントでは、実際の機能開発を通じてSpeckitワークフローを学びます。

## 目次

- [例1: シンプルな機能 - ヘルスチェックAPI](#例1-シンプルな機能---ヘルスチェックapi)
- [例2: 中規模機能 - ユーザー認証](#例2-中規模機能---ユーザー認証)
- [例3: 複雑な機能 - 決済システム](#例3-複雑な機能---決済システム)
- [よくある問題と解決策](#よくある問題と解決策)

---

## 例1: シンプルな機能 - ヘルスチェックAPI

この例では、最もシンプルな機能を通じて基本的なワークフローを学びます。

### 要件

> サーバーの稼働状態を確認するヘルスチェックエンドポイントを追加したい

### Step 1: 仕様策定

```bash
/speckit.specify ヘルスチェックエンドポイントを追加したい。サーバーの稼働状態とデータベース接続を確認できるようにする。
```

**実行結果**:

```
✅ 機能仕様を作成しました

Branch: 1-health-check
Spec: specs/1-health-check/spec.md

生成されたユーザーストーリー:
- US1 (P1): 基本的なヘルスチェック
- US2 (P2): データベース接続確認

次のステップ: /speckit.plan
```

**生成された spec.md の抜粋**:

```markdown
## User Scenarios & Testing

### User Story 1 - 基本ヘルスチェック (Priority: P1)

運用チームがサーバーの稼働状態を即座に確認できる。

**Independent Test**: エンドポイントにアクセスし、200 OKレスポンスが返る

**Acceptance Scenarios**:
1. **Given** サーバー稼働中、**When** /health にアクセス、**Then** 200 OK + "healthy"
2. **Given** サーバー起動中、**When** 短時間で複数回アクセス、**Then** すべて200 OK

### User Story 2 - データベース接続確認 (Priority: P2)

運用チームがデータベースの接続状態も確認できる。

## Requirements

- **FR-001**: システムはHTTP GETで/healthエンドポイントを提供する
- **FR-002**: レスポンスはJSON形式とする
- **FR-003**: データベース接続可能な場合、statusをhealthyとする
- **FR-004**: データベース接続不可の場合、statusをdegradedとする

## Success Criteria

- **SC-001**: ヘルスチェックは100ms以内にレスポンスを返す
- **SC-002**: 毎秒100回のリクエストに対応できる
```

### Step 2: 技術計画

曖昧さがないため、`/speckit.clarify` をスキップして計画へ進みます。

```bash
/speckit.plan
```

**実行結果**:

```
✅ 実装計画を作成しました

生成されたファイル:
- specs/1-health-check/plan.md
- specs/1-health-check/research.md
- specs/1-health-check/data-model.md (N/A - データなし)
- specs/1-health-check/contracts/health.openapi.yaml
- specs/1-health-check/quickstart.md

技術スタック:
- Python 3.11 + FastAPI
- PostgreSQL (既存)
- pytest

次のステップ: /speckit.tasks
```

**生成された contracts/health.openapi.yaml**:

```yaml
openapi: 3.0.0
info:
  title: Health Check API
  version: 1.0.0

paths:
  /health:
    get:
      summary: サーバーヘルスチェック
      responses:
        '200':
          description: サーバー稼働中
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [healthy, degraded]
                  timestamp:
                    type: string
                    format: date-time
                  database:
                    type: object
                    properties:
                      connected:
                        type: boolean
```

### Step 3: タスク分解

```bash
/speckit.tasks
```

**実行結果**:

```
✅ タスクリストを生成しました

Total Tasks: 7
- Phase 1 (Setup): 2 tasks
- Phase 2 (US1 - P1): 3 tasks
- Phase 3 (US2 - P2): 1 task
- Phase 4 (Polish): 1 task

Parallel Opportunities: 3 tasks

MVP Scope: Phase 1-2 (5 tasks)

次のステップ: /speckit.implement
```

**生成された tasks.md の抜粋**:

```markdown
## Phase 1: Setup

- [ ] T001 プロジェクト構造を確認 (既存)
- [ ] T002 [P] ヘルスチェックルーティングを設定 src/api/routes.py

## Phase 2: User Story 1 - 基本ヘルスチェック (P1)

**Story Goal**: サーバー稼働状態を確認できる

### Implementation Tasks

- [ ] T003 [US1] ヘルスチェックエンドポイントを作成 src/api/health.py
- [ ] T004 [P] [US1] レスポンススキーマを定義 src/schemas/health.py
- [ ] T005 [P] [US1] ヘルスチェックのルートを登録 src/api/routes.py

## Phase 3: User Story 2 - データベース確認 (P2)

- [ ] T006 [US2] データベース接続チェックを追加 src/api/health.py

## Phase 4: Polish

- [ ] T007 [P] 統合テストを作成 tests/integration/test_health.py
```

### Step 4: 実装実行

```bash
/speckit.implement
```

**実行プロセス**:

```
チェックリスト検証...
✅ チェックリストなし

Phase 1: Setup 開始...

✅ T001 完了: プロジェクト構造を確認
✅ T002 完了: ルーティング設定を追加

Phase 1 完了 (2/2 tasks)

Phase 2: User Story 1 開始...

✅ T003 完了: ヘルスチェックエンドポイントを作成
   作成: src/api/health.py

✅ T004 完了: レスポンススキーマを定義
   作成: src/schemas/health.py

✅ T005 完了: ルートを登録
   更新: src/api/routes.py

Phase 2 完了 (3/3 tasks)

Phase 3: User Story 2 開始...

✅ T006 完了: データベース接続チェックを追加
   更新: src/api/health.py

Phase 3 完了 (1/1 tasks)

Phase 4: Polish 開始...

✅ T007 完了: 統合テストを作成
   作成: tests/integration/test_health.py

Phase 4 完了 (1/1 tasks)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎉 実装完了! (7/7 tasks)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

実装された機能:
✅ US1: 基本ヘルスチェック (P1)
✅ US2: データベース接続確認 (P2)

作成されたファイル:
- src/api/health.py
- src/schemas/health.py
- tests/integration/test_health.py

次のステップ:
1. テストを実行: pytest tests/integration/test_health.py
2. サーバーを起動: uvicorn src.main:app --reload
3. 動作確認: curl http://localhost:8000/health
```

### Step 5: テストと検証

```bash
# テスト実行
pytest tests/integration/test_health.py

# サーバー起動
uvicorn src.main:app --reload

# 動作確認
curl http://localhost:8000/health
```

**レスポンス例**:

```json
{
  "status": "healthy",
  "timestamp": "2025-11-16T10:30:00Z",
  "database": {
    "connected": true
  }
}
```

### まとめ: シンプルな機能の開発

**所要時間**: 約5分 (仕様策定から実装完了まで)

**学んだこと**:
- 基本的なワークフローの流れ
- 仕様書の自動生成
- タスクの段階的実行
- MVP (P1のみ) と追加機能 (P2) の分離

---

## 例2: 中規模機能 - ユーザー認証

この例では、より現実的な機能開発を通じて、曖昧さの解消と品質チェックを学びます。

### 要件

> ユーザー認証機能を追加したい。OAuth2でGoogleとGitHubのログインに対応し、セッション管理も行う。

### Step 1: 仕様策定

```bash
/speckit.specify ユーザー認証機能を追加したい。OAuth2でGoogleとGitHubのログインに対応し、セッション管理も行う。パスワードリセット機能も必要。
```

**実行結果**:

```
✅ 機能仕様を作成しました

Branch: 2-user-auth
Spec: specs/2-user-auth/spec.md

生成されたユーザーストーリー:
- US1 (P1): Googleログイン
- US2 (P2): GitHubログイン
- US3 (P3): パスワードリセット

⚠️ 曖昧な部分が検出されました:
- セッションの有効期限
- OAuth2リダイレクトURL
- パスワードリセットの有効期限

次のステップ: /speckit.clarify で曖昧さを解消
```

### Step 2: 曖昧さの解消

```bash
/speckit.clarify
```

**対話プロセス**:

```
質問1/3: セッションの有効期限

コンテキスト: FR-007でセッション管理が必要ですが、有効期限が未定です

知りたいこと: セッションの有効期限はどのくらいにしますか？

推奨: オプションB - 24時間が一般的で、UXとセキュリティのバランスが良い

| オプション | 説明 |
|----------|------|
| A | 1時間 - セキュア、頻繁な再ログイン |
| B | 24時間 - バランス良、一般的 |
| C | 1週間 - UX良、セキュリティリスク高 |

回答: _
```

**ユーザーの回答**: `B` (24時間を選択)

```
✅ 更新: セッションは24時間有効

質問2/3: パスワードリセットの有効期限

提案: 24時間 - 業界標準

回答 (<=5語): _
```

**ユーザーの回答**: `yes` (提案を採用)

```
✅ 更新: パスワードリセットリンクは24時間有効

質問3/3: リダイレクトURLの設定

知りたいこと: OAuth2コールバックURLのベースは？

提案: https://yourapp.com/auth/callback

回答 (<=5語): _
```

**ユーザーの回答**: `http://localhost:8000/auth/callback` (開発環境)

```
✅ 更新: リダイレクトURL設定完了

━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 曖昧さ解消完了 (3/3 質問)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

更新されたセクション:
- Functional Requirements (FR-007, FR-008, FR-012)
- Clarifications

次のステップ: /speckit.plan
```

### Step 3: 技術計画

```bash
/speckit.plan
```

**実行結果**:

```
✅ 実装計画を作成しました

Phase 0: Research 完了
  決定事項:
  - OAuth2ライブラリ: authlib (FastAPI統合良)
  - セッション管理: Redis (高速、スケーラブル)

Phase 1: Design 完了
  生成ファイル:
  - data-model.md: User, Session, OAuthProvider エンティティ
  - contracts/auth.openapi.yaml: OAuth2フロー定義
  - quickstart.md: ローカル開発手順

技術スタック:
- Python 3.11 + FastAPI
- PostgreSQL (ユーザーデータ)
- Redis (セッション)
- authlib

次のステップ: /speckit.tasks
```

### Step 4: タスク分解

```bash
/speckit.tasks
```

**実行結果**:

```
✅ タスクリストを生成しました

Total Tasks: 18
- Phase 1 (Setup): 4 tasks
- Phase 2 (Foundational): 3 tasks
- Phase 3 (US1 - Googleログイン): 5 tasks
- Phase 4 (US2 - GitHubログイン): 2 tasks
- Phase 5 (US3 - パスワードリセット): 3 tasks
- Phase 6 (Polish): 1 task

Parallel Opportunities: 8 tasks

MVP Scope: Phase 1-3 (12 tasks)

次のステップ: /speckit.analyze (推奨) または /speckit.implement
```

### Step 5: 整合性検証 (推奨)

```bash
/speckit.analyze
```

**レポート**:

```markdown
## Specification Analysis Report

| ID | Category | Severity | Location | Summary | Recommendation |
|----|----------|----------|----------|---------|----------------|
| C1 | Coverage | MEDIUM | spec.md FR-013 | セキュリティヘッダー要件にタスクなし | セキュリティミドルウェアタスクを追加 |
| T1 | Terminology | LOW | spec.md, plan.md | "ユーザー"/"User"の揺れ | "User"に統一 |

**Coverage Summary**:

| Requirement | Has Task? | Task IDs |
|-------------|-----------|----------|
| FR-001: OAuth2認証 | ✅ | T006, T007, T008 |
| FR-013: セキュリティヘッダー | ❌ | - |

**Metrics**:
- Coverage: 92% (12/13)
- Critical Issues: 0
- High Issues: 0
- Medium Issues: 1

## Next Actions

✅ MEDIUM問題のみ: 実装中に対応可能
推奨: tasks.mdにT019 (セキュリティヘッダー) を追加
```

**対応**: tasks.md を手動編集してタスクを追加

```markdown
## Phase 6: Polish

- [ ] T018 [P] 統合テストを作成 tests/integration/test_auth.py
- [ ] T019 [P] セキュリティヘッダーミドルウェアを追加 src/middleware/security.py
```

### Step 6: 品質チェックリスト作成

```bash
/speckit.checklist security
```

**生成されたチェックリスト**:

```markdown
# Security Checklist: ユーザー認証

## OAuth2 Security

- [ ] stateパラメータでCSRF保護
- [ ] トークンは予測不可能 (32文字以上ランダム)
- [ ] セッション有効期限が適切 (24時間)
- [ ] ログアウト機能が実装されている

## Data Protection

- [ ] OAuth2トークンは暗号化して保存
- [ ] HTTPS強制 (本番環境)
- [ ] 機密情報はログに出力しない

## Rate Limiting

- [ ] ログイン試行回数制限 (10回/時間)
- [ ] API呼び出し制限

## Monitoring

- [ ] 認証失敗をログに記録
- [ ] 異常なアクティビティを検出 (同一IPから大量リクエスト)
```

### Step 7: 実装実行

```bash
/speckit.implement
```

**実行プロセス** (抜粋):

```
チェックリスト検証...

| Checklist | Total | Completed | Incomplete | Status |
|-----------|-------|-----------|------------|--------|
| security.md | 9    | 0         | 9          | ✗ FAIL |

⚠️ セキュリティチェックリストが未完了です。
これは実装後に確認するためのチェックリストです。
実装を続行しますか? (yes/no)
```

**ユーザーの回答**: `yes`

```
Phase 1: Setup 開始...

✅ T001 完了: 依存関係を追加
   更新: requirements.txt (authlib, redis)

✅ T002 完了: 環境変数テンプレートを作成
   作成: .env.example

✅ T003 [P] 完了: Redisクライアント設定
   作成: src/config/redis.py

✅ T004 [P] 完了: OAuth2設定を追加
   作成: src/config/oauth.py

Phase 1 完了 (4/4 tasks)

Phase 2: Foundational 開始...

✅ T005 完了: Userモデルを作成
   作成: src/models/user.py

✅ T006 [P] 完了: Sessionモデルを作成
   作成: src/models/session.py

✅ T007 [P] 完了: OAuthProviderモデルを作成
   作成: src/models/oauth_provider.py

Phase 2 完了 (3/3 tasks)

Phase 3: User Story 1 - Googleログイン 開始...

✅ T008 [US1] 完了: AuthServiceを作成
   作成: src/services/auth_service.py

✅ T009 [P] [US1] 完了: SessionServiceを作成
   作成: src/services/session_service.py

✅ T010 [US1] 完了: Googleログインエンドポイントを作成
   作成: src/api/auth_routes.py

✅ T011 [P] [US1] 完了: コールバックエンドポイントを作成
   更新: src/api/auth_routes.py

✅ T012 [US1] 完了: ログアウトエンドポイントを作成
   更新: src/api/auth_routes.py

Phase 3 完了 (5/5 tasks) - ✅ MVP達成!

Phase 4, 5, 6を続けますか? (yes/skip)
```

**ユーザーの回答**: `yes` (全機能を実装)

```
[Phase 4, 5, 6 の実行...]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎉 実装完了! (19/19 tasks)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

実装された機能:
✅ US1: Googleログイン (P1) - MVP
✅ US2: GitHubログイン (P2)
✅ US3: パスワードリセット (P3)

作成されたファイル: 15ファイル

次のステップ:
1. セキュリティチェックリストを確認
2. テストを実行: pytest tests/
3. ローカルで動作確認: quickstart.mdを参照
4. セキュリティチェックリストの各項目を検証
```

### Step 8: セキュリティチェックリスト検証

実装後、チェックリストを確認:

```bash
# チェックリストを開いて確認
vim specs/2-user-auth/checklists/security.md
```

各項目を検証し、チェックマークを付ける:

```markdown
## OAuth2 Security

- [X] stateパラメータでCSRF保護 ← 実装確認済み
- [X] トークンは予測不可能 ← secrets.token_urlsafe(32)使用
- [X] セッション有効期限が適切 ← 24時間設定済み
- [X] ログアウト機能が実装されている ← エンドポイント確認
```

### まとめ: 中規模機能の開発

**所要時間**: 約15分

**学んだこと**:
- `/speckit.clarify` で曖昧さを対話形式で解消
- `/speckit.analyze` で整合性を事前検証
- `/speckit.checklist` で品質基準を明確化
- MVP (Phase 1-3) と追加機能の分離
- セキュリティチェックリストによる実装後検証

---

## 例3: 複雑な機能 - 決済システム

この例では、複雑な機能開発を通じて、憲章の活用と GitHub連携を学びます。

### 要件

> Stripe APIを使った決済機能を実装したい。クレジットカード決済、サブスクリプション、払い戻しに対応。

### Step 0: プロジェクト憲章の設定 (初回のみ)

```bash
/speckit.constitution
```

**対話プロセス**:

```
プロジェクト憲章を作成します。

プロジェクトの核となる原則を教えてください:

1. アーキテクチャパターン (例: マイクロサービス、モノリス):
```

**ユーザーの回答**: `ライブラリファースト。すべての機能は独立したライブラリとして開始`

```
2. テスト戦略 (例: TDD必須、カバレッジ80%以上):
```

**ユーザーの回答**: `TDD必須。契約テスト必須。`

```
3. その他の重要な原則 (最大3つ):
```

**ユーザーの回答**: `API契約優先。セキュリティ最優先。シンプルさを保つ。`

```
✅ 憲章を作成しました

.specify/memory/constitution.md

次のステップ: /speckit.specify で機能開発を開始
```

### Step 1: 仕様策定

```bash
/speckit.specify Stripe APIを使った決済機能を実装したい。クレジットカード決済、月次サブスクリプション、払い戻しに対応する必要がある。
```

**実行結果**:

```
✅ 機能仕様を作成しました

Branch: 3-payment
Spec: specs/3-payment/spec.md

生成されたユーザーストーリー:
- US1 (P1): 1回限りの決済
- US2 (P2): サブスクリプション
- US3 (P3): 払い戻し

次のステップ: /speckit.clarify
```

### Step 2: 技術計画

```bash
/speckit.plan
```

**憲章チェック**:

```
⚠️ 憲章チェック実行中...

❌ CRITICAL: 憲章違反を検出

| 原則 | 違反内容 | 箇所 |
|------|---------|------|
| TDD必須 | テスト戦略が未定義 | plan.md |
| API契約優先 | 契約テストが計画に含まれていない | plan.md |

修正が必要です。研究フェーズを再実行します...

✅ 修正完了

Phase 0: Research
  追加された決定事項:
  - テスト戦略: TDD (契約テスト → 実装)
  - 契約テスト: pact または OpenAPI契約テスト

次のステップ: /speckit.tasks
```

**ポイント**: 憲章により、TDDと契約テストが強制されました。

### Step 3: タスク分解

```bash
/speckit.tasks
```

**実行結果**:

```
✅ タスクリストを生成しました

Total Tasks: 25
- Phase 1 (Setup): 5 tasks
- Phase 2 (契約テスト): 6 tasks ← 憲章により追加
- Phase 3 (US1 - 決済): 6 tasks
- Phase 4 (US2 - サブスク): 4 tasks
- Phase 5 (US3 - 払い戻し): 3 tasks
- Phase 6 (Polish): 1 task

MVP Scope: Phase 1-3 (17 tasks)
```

**tasks.md の抜粋** (憲章の影響):

```markdown
## Phase 2: 契約テスト (憲章: API契約優先)

**Goal**: すべてのAPI契約のテストを先に作成 (TDD)

- [ ] T006 [P] Stripe決済API契約テストを作成 tests/contract/test_payment_contract.py
- [ ] T007 [P] Stripeサブスク契約テストを作成 tests/contract/test_subscription_contract.py
- [ ] T008 [P] 払い戻しAPI契約テストを作成 tests/contract/test_refund_contract.py
- [ ] T009 内部決済API契約テストを作成 tests/contract/test_payment_api_contract.py

**Note**: すべてのテストは最初は失敗する (Red) → 実装で成功させる (Green)
```

### Step 4: GitHub Issue連携

```bash
/speckit.taskstoissues
```

**実行結果**:

```
✅ GitHub Issueを作成しました

作成されたIssue: 25個

Phase別の分布:
- Setup: #1-#5
- 契約テスト: #6-#11
- US1 (P1): #12-#17
- US2 (P2): #18-#21
- US3 (P3): #22-#24
- Polish: #25

依存関係:
- #12-#17 は #6-#11 (契約テスト) 完了後に着手可能
- #18-#21 は #12-#17 完了後に着手可能

マイルストーン:
- v1.0 (MVP): #1-#17
- v1.1: #18-#21
- v1.2: #22-#25

GitHub: https://github.com/youruser/yourrepo/issues
```

### Step 5: 実装実行 (TDD方式)

```bash
/speckit.implement
```

**実行プロセス** (TDD強調):

```
Phase 2: 契約テスト 開始...

✅ T006 完了: Stripe決済API契約テストを作成
   作成: tests/contract/test_payment_contract.py

テストを実行しています...
❌ FAILED: test_create_payment_intent (期待通り - Red)

✅ T007 [P] 完了: Stripeサブスク契約テストを作成
✅ T008 [P] 完了: 払い戻し契約テストを作成
✅ T009 完了: 内部API契約テストを作成

Phase 2 完了 (契約テスト全作成)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ Red Phase Complete
すべての契約テストが失敗しています (期待通り)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

次: 実装フェーズでテストをGreenにします

Phase 3: User Story 1 - 決済 開始...

✅ T010 [US1] 完了: PaymentServiceを作成
   作成: src/services/payment_service.py

テストを実行しています...
✅ PASSED: test_create_payment_intent (Green!)

✅ T011 [US1] 完了: StripeClientを作成
✅ T012 [US1] 完了: Paymentモデルを作成

[残りのタスク実行...]

Phase 3 完了 (6/6 tasks)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Green Phase Complete
すべての契約テストが成功しています
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MVP達成! (Phase 1-3 完了)
```

### Step 6: リファクタリング (必要に応じて)

**Refactorフェーズ**: コードの整理、重複排除

```python
# 例: StripeClientの共通化
# Before (重複)
# payment_service.py と subscription_service.py で別々にStripeクライアントを初期化

# After (リファクタリング)
# src/clients/stripe_client.py に共通化
```

### まとめ: 複雑な機能の開発

**所要時間**: 約30-45分

**学んだこと**:
- **憲章の活用**: プロジェクト全体の原則を強制
- **TDDの実践**: Red (テスト失敗) → Green (実装) → Refactor
- **契約テスト優先**: API仕様を先にテストで固める
- **GitHub連携**: タスクをIssueに変換し、チーム開発をサポート
- **段階的リリース**: MVP (v1.0) → v1.1 → v1.2

**Red-Green-Refactorサイクル**:
1. **Red**: 契約テストを作成 (失敗)
2. **Green**: 実装してテストを成功させる
3. **Refactor**: コードを整理 (テストは成功のまま)

---

## よくある問題と解決策

### 問題1: 仕様書が技術詳細に偏っている

**症状**:

```markdown
## Requirements
- **FR-001**: FastAPIでPOST /usersエンドポイントを作る
- **FR-002**: PostgreSQLのusersテーブルにデータを保存
```

**原因**: WHATではなくHOWを書いている

**解決策**:

```markdown
## Requirements
- **FR-001**: システムは新しいユーザーを登録できる
- **FR-002**: ユーザー情報は永続化される
```

**ヒント**: 「〜という技術を使って」を削除し、「〜できる」形式に変える

### 問題2: タスクが大きすぎる

**症状**:

```markdown
- [ ] T001 ユーザー認証を実装する
```

**原因**: 1つのタスクに複数の作業が含まれている

**解決策**:

```markdown
- [ ] T001 Userモデルを作成 src/models/user.py
- [ ] T002 AuthServiceを作成 src/services/auth_service.py
- [ ] T003 ログインエンドポイントを作成 src/api/auth_routes.py
- [ ] T004 ログアウトエンドポイントを作成 src/api/auth_routes.py
```

**ヒント**: 1タスク = 1ファイルまたは1つの明確な変更

### 問題3: ユーザーストーリーが独立していない

**症状**:

US1を実装しないとUS2をテストできない

**原因**: ストーリー間に依存関係がある

**解決策**:

ストーリーを再構成:

**Before**:
- US1: ユーザー登録
- US2: ユーザーログイン (US1に依存)

**After**:
- US1: ユーザー登録とログイン (1つのストーリーに統合)
- US2: ソーシャルログイン (独立)

**ヒント**: 各ストーリーは単独でデモ・テスト可能でなければならない

### 問題4: 曖昧さが多すぎる

**症状**:

spec.mdに10個以上の `[NEEDS CLARIFICATION]` マーカー

**原因**: 初期説明が不十分

**解決策**:

1. **より詳しい説明で再実行**:

```bash
/speckit.specify ユーザー認証機能。
要件:
- OAuth2 (Google, GitHub)
- セッションは24時間有効
- パスワードリセットはメールで24時間有効なリンク
- 2要素認証は任意
```

2. **または `/speckit.clarify` で質問に答える**

**ヒント**: 最初から詳しく書くと、曖昧さマーカーが減る

### 問題5: 憲章違反が多い

**症状**:

```
❌ CRITICAL: 3件の憲章違反
```

**原因**: 計画が憲章の原則と合っていない

**解決策**:

1. **憲章を確認**: `.specify/memory/constitution.md` を読む
2. **plan.md を手動修正**: 憲章に沿った技術選定や戦略を記述
3. **再計画**: `/speckit.plan` を再実行

**例**:

憲章: "TDD必須"
→ plan.mdに「テスト戦略: pytest, TDD方式 (Red-Green-Refactor)」を追加

### 問題6: カバレッジギャップ

**症状**:

```
FR-009: セキュリティヘッダーを設定
→ 対応するタスクなし
```

**原因**: タスク生成時に要件が見落とされた

**解決策**:

1. **tasks.md を手動編集**:

```markdown
## Phase 6: Polish

- [ ] T020 [P] セキュリティヘッダーミドルウェアを追加 src/middleware/security.py
```

2. **または `/speckit.tasks` を再実行** (既存タスクは保持される)

### 問題7: 並列実行でエラー

**症状**:

```
T005 [P] と T006 [P] を並列実行中...
❌ T005, T006 両方失敗: 同じファイルを同時に編集
```

**原因**: `[P]` マーカーが誤っている (同じファイルを扱うタスク)

**解決策**:

tasks.md を修正:

```markdown
- [ ] T005 AuthServiceの基本構造を作成 src/services/auth.py
- [ ] T006 AuthServiceにGoogle設定を追加 src/services/auth.py
```

`[P]` を削除 (順次実行)

### 問題8: MVPの範囲が不明

**症状**:

「最小限の機能」がどこまでか分からない

**解決策**:

tasks.md の「Implementation Strategy」セクションを確認:

```markdown
## Implementation Strategy

**MVP Scope**: Phase 1-3 (US1のみ)

**Reasoning**:
- US1 (Googleログイン) だけで基本的な認証が可能
- US2 (GitHubログイン) はUS1の拡張、独立してリリース可能
```

**ヒント**: 通常、P1 (最優先) のストーリーだけでMVP

### 問題9: チェックリストが完了しない

**症状**:

```
security.md: 2/10 完了
→ 実装を続行できない
```

**解決策**:

**オプション1**: チェックリストを実装後に確認する目的で使う

```bash
# 実装時に "yes" で続行
/speckit.implement
> 実装を続行しますか? yes
```

実装後、チェックリストを確認:

```bash
# 各項目を検証してチェックマーク
vim specs/feature/checklists/security.md
```

**オプション2**: チェックリストを事前に完了させる

仕様や計画段階でチェック:

```markdown
- [X] パスワードは安全にハッシュ化 ← plan.mdで bcrypt 使用を確認
- [X] HTTPS強制 ← plan.mdで本番環境HTTPS必須を確認
```

---

## ベストプラクティス

### 1. 小さく始める

最初は簡単な機能から始めましょう:
- ヘルスチェック
- 単純なCRUD
- 静的ページ

### 2. MVP優先

すべての機能を一度に実装せず、P1 (最優先) だけをまず完成させる:

```bash
/speckit.implement
# Phase 3 (US1 - P1) 完了後
> Phase 4を続けますか? skip

# MVPをテスト・デプロイ
# 問題なければ残りを実装
/speckit.implement  # 再開してPhase 4以降を実行
```

### 3. 早期フィードバック

各フェーズでステークホルダーにレビューを依頼:
- spec.md → ビジネス側
- plan.md → 技術リード
- tasks.md → チーム全体

### 4. 憲章を最初に設定

プロジェクト開始時に憲章を作成し、全員の合意を得る:

```bash
# 最初に1回だけ実行
/speckit.constitution
```

これにより、後で「TDDすべきだった」などの手戻りを防げます。

### 5. チェックリストを活用

品質基準を明確化:

```bash
/speckit.checklist security
/speckit.checklist ux
/speckit.checklist performance
```

実装後、チェックリストで漏れを確認。

### 6. 並列実行を活用

`[P]` マーカーのタスクはチームで分担:

```markdown
- [ ] T005 [P] [US1] UserService src/services/user.py → Alice
- [ ] T006 [P] [US1] AuthService src/services/auth.py → Bob
```

### 7. GitHub連携でチーム開発

```bash
/speckit.taskstoissues
```

Issue番号でコミット:

```bash
git commit -m "feat: Implement UserService (fixes #5)"
```

---

次は [アーキテクチャ](./アーキテクチャ.md) でシステムの設計思想を深く理解しましょう。
