# ワークフロー詳細ガイド

このドキュメントでは、Speckitワークフローの各フェーズを詳しく解説します。

## 目次

- [全体の流れ](#全体の流れ)
- [フェーズ1: 仕様策定](#フェーズ1-仕様策定)
- [フェーズ2: 曖昧さ解消](#フェーズ2-曖昧さ解消)
- [フェーズ3: 技術計画](#フェーズ3-技術計画)
- [フェーズ4: タスク分解](#フェーズ4-タスク分解)
- [フェーズ5: 整合性検証](#フェーズ5-整合性検証)
- [フェーズ6: 実装実行](#フェーズ6-実装実行)

## 全体の流れ

### ワークフローの目的

Speckitワークフローは、以下の3つの主要な目的を達成します:

1. **早期フィードバック**: 実装前に方向性を確認
2. **手戻り削減**: 段階的に詳細化することで、大きな変更を防ぐ
3. **品質保証**: 各フェーズでの検証により、要件漏れや矛盾を早期発見

### フェーズの依存関係

```
specify (必須) → clarify (任意) → plan (必須) → tasks (必須) → analyze (任意) → implement (必須)
    ↓                                  ↓              ↓
 spec.md                           plan.md       tasks.md
```

**必須フェーズ**: specify → plan → tasks → implement
**推奨フェーズ**: + clarify + analyze

## フェーズ1: 仕様策定

### コマンド

```bash
/speckit.specify ユーザー認証機能を追加したい。メールアドレスとパスワードでログインできるようにする。
```

### 何が起こるか

1. **ブランチ作成**
   - 既存のブランチを確認し、次の番号を割り当て
   - 例: `1-user-auth`, `2-payment-integration`
   - 自動的に新しいブランチにチェックアウト

2. **ディレクトリ作成**
   ```
   specs/1-user-auth/
   └── spec.md (初期化済み)
   ```

3. **仕様書生成**
   - ユーザーの入力を分析
   - ビジネス価値とユーザーニーズに変換
   - ユーザーストーリー形式で構造化

### 仕様書の構成

#### セクション1: ユーザーストーリー (必須)

ユーザーの視点から機能を記述します。

**例:**

```markdown
### ユーザーストーリー1 - アカウント作成 (優先度: P1)

新規ユーザーがメールアドレスとパスワードでアカウントを作成できる。

**なぜこの優先度**: 認証の基盤として最優先

**独立テスト**: アカウント作成フォームから登録し、確認メールが届くことで検証可能

**受入条件**:
1. **Given** 未登録のメールアドレス、**When** 有効なパスワードで登録、**Then** アカウントが作成される
2. **Given** 既存のメールアドレス、**When** 登録を試みる、**Then** エラーメッセージが表示される
```

**ポイント**:
- 優先度 (P1, P2, P3) を必ず付ける
- 各ストーリーは独立してテスト可能でなければならない
- 受入条件は Given-When-Then 形式

#### セクション2: 機能要件 (必須)

システムが満たすべき具体的な要件を列挙します。

**例:**

```markdown
- **FR-001**: システムはメールアドレスの形式を検証しなければならない
- **FR-002**: パスワードは最低8文字、英数字と記号を含む必要がある
- **FR-003**: ユーザーはパスワードをリセットできなければならない
```

**ポイント**:
- 「〜しなければならない (MUST)」形式で記述
- テスト可能な表現にする
- 技術的な実装方法は書かない

#### セクション3: 成功基準 (必須)

機能の成功を測定する具体的な指標を定義します。

**例:**

```markdown
- **SC-001**: ユーザーは2分以内にアカウント作成を完了できる
- **SC-002**: システムは1000人の同時ログインに対応できる
- **SC-003**: パスワードリセットの成功率が95%以上
```

**ポイント**:
- 数値で測定可能にする
- 技術非依存 (「APIレスポンス200ms」ではなく「ユーザーは待たされない」)
- ユーザー視点での価値

#### セクション4: 主要エンティティ (データがある場合)

**例:**

```markdown
- **ユーザー**: メールアドレス、パスワード(ハッシュ化)、作成日時、最終ログイン日時
- **セッション**: ユーザーとの関連、有効期限、トークン
```

### 品質検証

仕様策定が完了すると、自動的に品質チェックリストが作成されます:

```
specs/1-user-auth/checklists/requirements.md
```

以下の項目が自動検証されます:
- ✅ 実装詳細が含まれていないか
- ✅ ユーザー価値に焦点が当てられているか
- ✅ 必須セクションが完了しているか
- ✅ 要件がテスト可能か
- ✅ 成功基準が測定可能か

### ❌ よくある間違い

| ❌ 間違い | ✅ 正解 |
|---------|--------|
| FastAPIでログインエンドポイントを作る | ユーザーはメールアドレスでログインできる |
| JWTトークンを使う | ユーザーは一度ログインすれば、再ログイン不要 |
| PostgreSQLにユーザーテーブルを作る | システムはユーザー情報を永続化する |

**原則**: 仕様書には「何を」「なぜ」だけを書き、「どうやって」は書かない

## フェーズ2: 曖昧さ解消

### コマンド

```bash
/speckit.clarify
```

### いつ使うか

- 仕様書に `[NEEDS CLARIFICATION]` マーカーが含まれている
- AIが質問を通じて、曖昧な部分を明確化したい
- 実装前に認識を合わせたい

### 何が起こるか

1. **仕様書を分析**
   - 曖昧な表現を検出
   - 不足している決定事項を特定
   - 影響度の高い順に最大5つの質問を準備

2. **対話形式で質問**
   - 1つずつ質問を提示
   - AIが推奨回答を提案
   - ユーザーが選択または独自の回答を入力

3. **仕様書を更新**
   - 回答後、即座に仕様書に反映
   - `## Clarifications` セクションに記録
   - 関連する要件セクションを更新

### 質問の例

```markdown
## 質問1: 認証方法

**コンテキスト**: FR-006で認証が必要と記載されていますが、具体的な方法が未定です

**知りたいこと**: どの認証方式を使用しますか？

**推奨**: オプションA - OAuth2による認証が最も柔軟で拡張性が高い

| オプション | 説明 |
|----------|------|
| A | OAuth2 (Google, GitHub等) - 拡張性高、実装やや複雑 |
| B | メール+パスワード - シンプル、管理コスト高 |
| C | マジックリンク (パスワードレス) - UX良、メール依存 |

回答: Aまたは"yes"で推奨を採用、独自の回答も可能
```

### 質問の優先順位

質問は以下の順で優先度付けされます:

1. **スコープに影響** (最優先)
   - 機能の範囲が大きく変わる決定
   - 例: 「シングルサインオンは必要か？」

2. **セキュリティ/プライバシー**
   - 法的・倫理的に重要な決定
   - 例: 「個人情報の保存期間は？」

3. **ユーザー体験**
   - ユーザーの使いやすさに影響
   - 例: 「2要素認証は必須か任意か？」

4. **技術的詳細** (最後)
   - 実装方法の選択
   - 例: 「セッションの有効期限は？」

### 更新された仕様書

```markdown
## Clarifications

### セッション 2025-11-16

- Q: 認証方式は？ → A: OAuth2 (Google, GitHub)
- Q: パスワードリセットの有効期限は？ → A: 24時間

## Functional Requirements

- **FR-006**: システムはOAuth2 (Google, GitHub) で認証する
- **FR-007**: パスワードリセットリンクは24時間有効
```

### 制限事項

- 最大5つの質問まで
- 質問は影響度の高いものから
- 技術的詳細よりビジネス判断を優先

## フェーズ3: 技術計画

### コマンド

```bash
/speckit.plan
```

### 前提条件

- `spec.md` が完成している
- `[NEEDS CLARIFICATION]` マーカーが残っていない (または `/speckit.clarify` で解消済み)

### 何が起こるか

1. **Phase 0: 調査研究**
   - 技術スタックの選定理由を調査
   - ベストプラクティスを収集
   - `research.md` に記録

2. **Phase 1: 設計**
   - データモデル設計 → `data-model.md`
   - API契約定義 → `contracts/` ディレクトリ
   - クイックスタートガイド → `quickstart.md`
   - プロジェクト構造定義 → `plan.md`

3. **憲章チェック**
   - `.specify/memory/constitution.md` との整合性確認
   - 違反があればCRITICALエラー

### 生成されるファイル

#### plan.md - 実装計画書

```markdown
# Implementation Plan: ユーザー認証

**ブランチ**: `1-user-auth`
**日付**: 2025-11-16
**仕様**: [spec.md](./spec.md)

## Summary

OAuth2を使用したユーザー認証機能。Google, GitHubアカウントでログイン可能。

## Technical Context

**言語/バージョン**: Python 3.11
**主な依存関係**: FastAPI, SQLAlchemy, authlib
**ストレージ**: PostgreSQL
**テスト**: pytest
**ターゲットプラットフォーム**: Linuxサーバー
**プロジェクトタイプ**: Webアプリケーション

## Project Structure

### ソースコード

```
backend/
├── src/
│   ├── models/
│   │   └── user.py
│   ├── services/
│   │   └── auth_service.py
│   └── api/
│       └── auth_routes.py
└── tests/
    ├── unit/
    └── integration/
```
```

#### research.md - 技術調査

```markdown
# Research: 認証方式

## Decision: OAuth2 with authlib

**Rationale**:
- 業界標準、セキュリティ実績あり
- Google, GitHub等の主要プロバイダーをサポート
- authlibはPython用の成熟したライブラリ

**Alternatives considered**:
- django-allauth: Django専用、FastAPIには不向き
- Auth0: サードパーティ依存、コスト増
```

#### data-model.md - データモデル

```markdown
# Data Model: ユーザー認証

## Entities

### User
- **id**: UUID (主キー)
- **email**: String (一意、インデックス)
- **provider**: String (google, github)
- **provider_id**: String (プロバイダーのユーザーID)
- **created_at**: DateTime
- **last_login**: DateTime

**Relationships**:
- User 1:N Session

### Session
- **id**: UUID (主キー)
- **user_id**: UUID (外部キー → User)
- **token**: String (一意)
- **expires_at**: DateTime
- **created_at**: DateTime

**Validation Rules**:
- emailは有効な形式でなければならない
- tokenは最低32文字のランダム文字列
```

#### contracts/ - API仕様

```yaml
# contracts/auth.openapi.yaml

openapi: 3.0.0
info:
  title: Authentication API
  version: 1.0.0

paths:
  /auth/login:
    post:
      summary: OAuth2ログイン開始
      parameters:
        - name: provider
          in: query
          schema:
            type: string
            enum: [google, github]
      responses:
        '302':
          description: プロバイダーのログインページにリダイレクト
```

### Phase区切り

計画フェーズは以下のように段階的に進みます:

| Phase | 成果物 | 目的 |
|-------|--------|------|
| Phase 0 | research.md | 技術選定の根拠を記録 |
| Phase 1 | data-model.md, contracts/, quickstart.md | 設計の詳細化 |

**注意**: `/speckit.plan` はPhase 1まで実行し、タスク生成(`/speckit.tasks`)へ進みます。

## フェーズ4: タスク分解

### コマンド

```bash
/speckit.tasks
```

### 前提条件

- `plan.md` が完成している
- データモデルとAPI契約が定義されている

### 何が起こるか

1. **設計ドキュメントを読み込み**
   - plan.md から技術スタックと構造を抽出
   - spec.md からユーザーストーリーを抽出
   - data-model.md からエンティティを抽出
   - contracts/ からAPIエンドポイントを抽出

2. **タスクを生成**
   - ユーザーストーリーごとにグループ化
   - 依存関係を分析
   - 並列実行可能なタスクをマーク

3. **tasks.md を生成**

### タスクの構造

#### タスクフォーマット (厳密に遵守)

```
- [ ] [TaskID] [P?] [Story?] 説明とファイルパス
```

**構成要素**:
- `- [ ]`: チェックボックス (必須)
- `[T001]`: タスクID (連番、必須)
- `[P]`: 並列実行可能マーカー (任意)
- `[US1]`: ユーザーストーリーラベル (ストーリーフェーズで必須)
- 説明 + ファイルパス: 具体的な作業内容

#### 例

```markdown
## Phase 1: セットアップ

- [ ] T001 プロジェクト構造を作成 (plan.mdに従って)
- [ ] T002 [P] 依存関係をインストール (requirements.txt)
- [ ] T003 [P] データベースマイグレーション設定 (alembic)

## Phase 2: 基盤タスク

- [ ] T004 Userモデルを作成 src/models/user.py
- [ ] T005 Sessionモデルを作成 src/models/session.py

## Phase 3: ユーザーストーリー1 - OAuth2ログイン (P1)

**ストーリー目標**: ユーザーがGoogleアカウントでログインできる

**独立テスト基準**: Googleログインボタンをクリックし、認証後にダッシュボードが表示される

### 実装タスク

- [ ] T006 [US1] OAuth2設定をAuthServiceに追加 src/services/auth_service.py
- [ ] T007 [US1] ログインエンドポイントを作成 src/api/auth_routes.py
- [ ] T008 [P] [US1] コールバックエンドポイントを作成 src/api/auth_routes.py
- [ ] T009 [US1] セッション管理ロジックを実装 src/services/session_service.py

## Phase 4: ユーザーストーリー2 - GitHubログイン (P2)

**ストーリー目標**: GitHubアカウントでもログインできる

**独立テスト基準**: GitHubログインボタンで認証可能

### 実装タスク

- [ ] T010 [P] [US2] GitHub OAuth2設定を追加 src/services/auth_service.py
- [ ] T011 [P] [US2] GitHubプロバイダーを統合 src/api/auth_routes.py

## Phase 5: 仕上げ

- [ ] T012 [P] 統合テストを作成 tests/integration/test_auth_flow.py
- [ ] T013 エラーハンドリングを追加 src/api/error_handlers.py
```

### タスクの組織化原則

#### 1. フェーズ構造

```
Phase 1: Setup           → プロジェクト初期化
Phase 2: Foundational    → 全ストーリーで共通の基盤
Phase 3+: User Stories   → 各ストーリー (優先度順)
Final Phase: Polish      → 横断的な関心事
```

#### 2. ストーリーごとの独立性

各ユーザーストーリーは独立して:
- 開発できる
- テストできる
- デプロイできる
- デモできる

**MVPの定義**: 通常、P1 (最優先) のストーリーだけでMVPとなる

#### 3. 並列実行の活用

`[P]` マーカーが付いたタスクは同時に実行可能:

```markdown
- [ ] T006 [P] [US1] AuthService実装
- [ ] T007 [P] [US1] SessionService実装
```

これらは異なるファイルなので並列実行OK。

**並列不可の例**:
```markdown
- [ ] T006 [US1] AuthService実装 src/services/auth.py
- [ ] T007 [US1] AuthServiceにGoogle設定追加 src/services/auth.py
```

同じファイルなので順次実行が必要。

### 依存関係グラフ

tasks.md には依存関係の図も含まれます:

```markdown
## Dependencies

Setup → Foundational → US1 (P1) → US2 (P2) → Polish
                    ↘ US2 (P2) ↗

**並列実行の機会**:
- US1とUS2は並列開発可能 (Foundational完了後)
```

## フェーズ5: 整合性検証

### コマンド

```bash
/speckit.analyze
```

### いつ使うか

- タスク生成後、実装前に最終チェック
- spec.md, plan.md, tasks.md の整合性を確認

### 何が起こるか (読み取り専用)

このコマンドは**ファイルを一切変更しません**。分析レポートのみを出力します。

1. **セマンティックモデルを構築**
   - 要件一覧を抽出
   - ユーザーストーリー一覧を抽出
   - タスク一覧を抽出
   - それぞれをマッピング

2. **検出パス**
   - **重複検出**: 似た要件が複数ないか
   - **曖昧さ検出**: 「高速」「安全」など測定不能な表現
   - **不足検出**: タスクに対応する要件がない、逆も
   - **憲章整合性**: constitution.md との矛盾
   - **カバレッジギャップ**: 要件に対応するタスクがない
   - **不整合**: 用語の揺れ、矛盾する要件

3. **レポート生成**

### レポート例

```markdown
## Specification Analysis Report

| ID | Category | Severity | Location(s) | Summary | Recommendation |
|----|----------|----------|-------------|---------|----------------|
| A1 | Ambiguity | HIGH | spec.md:L45 | "高速なレスポンス"が測定不能 | "1秒以内にレスポンス"に変更 |
| C1 | Coverage Gap | MEDIUM | spec.md FR-009 | セキュリティ要件にタスクなし | T014: セキュリティヘッダー追加タスクを追加 |
| D1 | Duplication | LOW | spec.md:L120,134 | ログイン要件が2箇所 | 1つに統合 |

**Coverage Summary**:

| Requirement | Has Task? | Task IDs | Notes |
|-------------|-----------|----------|-------|
| FR-001: メール検証 | ✅ | T006 | |
| FR-002: OAuth2認証 | ✅ | T007, T008 | |
| FR-009: セキュリティヘッダー | ❌ | - | 要タスク追加 |

**Metrics**:
- Total Requirements: 12
- Total Tasks: 13
- Coverage: 92% (11/12)
- Critical Issues: 0
- High Issues: 1
- Medium Issues: 1
```

### 重大度レベル

| 重大度 | 意味 | 対応 |
|--------|------|------|
| CRITICAL | 憲章違反、実装不可 | 実装前に必ず修正 |
| HIGH | 矛盾、セキュリティ問題 | 実装前に修正推奨 |
| MEDIUM | 用語の揺れ、小さな不足 | 実装中に対応可能 |
| LOW | スタイル、小さな冗長性 | 任意 |

### 次のアクション

レポート最後に推奨アクションが表示されます:

```markdown
## Next Actions

- **CRITICAL issues found**: `/speckit.plan` を再実行して憲章違反を解消
- **HIGH issues only**: spec.md を手動編集し、曖昧な表現を明確化
- **No CRITICAL/HIGH**: `/speckit.implement` で実装開始可能
```

## フェーズ6: 実装実行

### コマンド

```bash
/speckit.implement
```

### 前提条件

- `tasks.md` が存在する
- チェックリスト (存在する場合) が完了している

### 何が起こるか

1. **チェックリスト検証**
   ```
   | Checklist | Total | Completed | Incomplete | Status |
   |-----------|-------|-----------|------------|--------|
   | ux.md     | 8     | 8         | 0          | ✓ PASS |
   | security.md | 5   | 3         | 2          | ✗ FAIL |
   ```

   不完全なチェックリストがあれば、確認を求められます:
   ```
   一部のチェックリストが未完了です。実装を続行しますか? (yes/no)
   ```

2. **コンテキスト読み込み**
   - tasks.md: タスク一覧
   - plan.md: 技術スタック
   - data-model.md: エンティティ定義
   - contracts/: API仕様

3. **プロジェクトセットアップ検証**
   - .gitignore が存在するか確認 (Gitリポジトリの場合)
   - 技術スタックに応じた無視ファイルを作成/検証
   - 例: Node.js → node_modules/, dist/, .env を追加

4. **タスクを段階的に実行**

### 実行ルール

#### 1. フェーズごとに実行

```
Phase 1 (Setup) 完了
  ↓
Phase 2 (Foundational) 完了
  ↓
Phase 3 (US1) 完了
  ↓
Phase 4 (US2) 完了
  ↓
Final Phase (Polish) 完了
```

前のフェーズが完了するまで次に進まない。

#### 2. 依存関係を尊重

- 順次タスク: 順番通りに実行
- 並列タスク `[P]`: 同時実行可能

**例**:
```markdown
- [ ] T004 Userモデルを作成      ← 先に実行
- [ ] T005 [P] Sessionモデルを作成  ← T004完了後、並列実行可能
- [ ] T006 [P] AuthServiceを作成    ← T004完了後、並列実行可能
- [ ] T007 AuthServiceにUserを統合 ← T004, T006完了後
```

#### 3. タスク完了のマーク

タスク完了時、即座にtasks.mdを更新:

```markdown
- [X] T004 Userモデルを作成 src/models/user.py
```

### 進捗レポート

各タスク完了後、進捗が報告されます:

```
✅ T004 完了: Userモデルを作成 (src/models/user.py)

Phase 2 進捗: 1/2 タスク完了 (50%)
全体進捗: 4/13 タスク完了 (31%)

次のタスク:
- T005 [P] Sessionモデルを作成
- T006 [P] AuthServiceを作成
```

### エラーハンドリング

タスク実行中にエラーが発生した場合:

1. **順次タスクのエラー**
   - 実行を停止
   - エラー詳細を報告
   - 次のステップを提案

2. **並列タスクのエラー**
   - 成功したタスクは続行
   - 失敗したタスクを報告
   - 依存タスクは保留

### 完了検証

全タスク完了後、以下を確認:

```markdown
## 実装完了レポート

✅ 全タスク完了: 13/13

**実装された機能**:
- ユーザーストーリー1: OAuth2ログイン (Google) ✅
- ユーザーストーリー2: OAuth2ログイン (GitHub) ✅

**成功基準の検証**:
- SC-001: ログイン完了時間 < 2分 → 要検証
- SC-002: 1000同時ユーザー対応 → 要負荷テスト

**次のステップ**:
1. 統合テストを実行
2. 成功基準を検証
3. コードレビュー
4. デプロイ準備
```

## 補足: 憲章 (Constitution)

### `/speckit.constitution` コマンド

プロジェクトの憲章 (不変の原則) を定義します。

```bash
/speckit.constitution
```

### 憲章の役割

憲章は、プロジェクト全体に適用される**交渉不可能な原則**を定義します:

- アーキテクチャパターン (例: ライブラリファースト)
- テスト戦略 (例: TDD必須)
- 品質基準 (例: カバレッジ80%以上)
- 技術制約 (例: Python 3.11以上)

### 憲章の例

```markdown
# My Project Constitution

## Core Principles

### I. Library-First
すべての機能は独立したライブラリとして開始する。
ライブラリは自己完結、独立してテスト可能、ドキュメント化必須。

### II. Test-First (NON-NEGOTIABLE)
TDD必須: テスト作成 → ユーザー承認 → テスト失敗 → 実装
Red-Green-Refactorサイクルを厳格に実施

### III. API Contract Testing
新しいライブラリ、契約変更、サービス間通信には契約テスト必須
```

### 憲章違反

`/speckit.analyze` で憲章違反が検出されると、**CRITICAL** として報告されます:

```markdown
| ID | Category | Severity | Summary |
|----|----------|----------|---------|
| K1 | Constitution | CRITICAL | plan.mdでTDDが省略されている |
```

## 補足: チェックリスト

### `/speckit.checklist` コマンド

特定ドメインの品質チェックリストを生成します。

```bash
/speckit.checklist security
```

### 利用可能なドメイン

- **security**: セキュリティ要件
- **ux**: ユーザー体験
- **performance**: パフォーマンス
- **accessibility**: アクセシビリティ
- **testing**: テスト網羅性

### チェックリストの例

```markdown
# Security Checklist: ユーザー認証

- [ ] パスワードは安全にハッシュ化されている (bcrypt/argon2)
- [ ] SQLインジェクション対策済み (パラメータ化クエリ)
- [ ] CSRF保護が有効
- [ ] セッショントークンは予測不可能
- [ ] HTTPS強制 (本番環境)
```

### 実装前の検証

`/speckit.implement` 実行時、未完了のチェックリストがあれば警告されます。

## まとめ: ワークフローの利点

### 1. 段階的な詳細化

```
概要 (specify) → 詳細 (plan) → 実行可能 (tasks) → コード
```

各段階で詳細度を上げることで、早期に方向性を確認できます。

### 2. トレーサビリティ

```
ユーザーストーリー → 機能要件 → タスク → コード
```

すべてが繋がっているため、「なぜこのコードが必要か」が明確です。

### 3. 品質保証

各フェーズでの検証により、以下を防ぎます:
- 要件漏れ
- 仕様の曖昧さ
- 設計の矛盾
- 実装の抜け漏れ

### 4. 柔軟な実装

ユーザーストーリーの独立性により:
- MVP (P1のみ) を素早くリリース
- P2, P3を段階的に追加
- 優先度の変更に柔軟に対応

---

次は [コマンドリファレンス](./コマンドリファレンス.md) で各コマンドの詳細を確認してください。
